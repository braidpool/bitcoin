#!/usr/bin/env python3
# Copyright (c) 2020 The Bitcoin Core developers
# Distributed under the MIT software license, see the accompanying
# file COPYING or http://www.opensource.org/licenses/mit-license.php.

import argparse
import json
import logging
import math
import os
import re
import struct
import sys
import subprocess
import time
import asyncio
import zmq
import zmq.asyncio
from zmq.utils.monitor import recv_monitor_message
import signal

# Add bitcoin's test harness framework to our import path.
PATH_BASE_CONTRIB_CPUNET = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))
PATH_BASE_TEST_FUNCTIONAL = os.path.abspath(os.path.join(PATH_BASE_CONTRIB_CPUNET, "..", "..", "test", "functional"))
sys.path.insert(0, PATH_BASE_TEST_FUNCTIONAL)

from test_framework.blocktools import script_BIP34_coinbase_height
from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxOut, from_hex, ser_uint256, tx_from_hex, uint256_from_str, hash256

EXIT_FAILURE = 1 # bitcoin-utils exit code

logging.basicConfig(
    format='%(asctime)s %(levelname)s %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S')

# This is the modified POW function for CPUNet. We just append the string
# "cpunet" to the end of the block header and hash that instead. It should match
# src/primitives/block.cpp:13, CBlockHeader::GetHash()
# This is copied/modifed from test/functional/test_framework/messages.py:732
def CBlockHeader_calc_sha256(self):
    if self.sha256 is None:
        r = b""
        r += self.nVersion.to_bytes(4, "little", signed=True)
        r += ser_uint256(self.hashPrevBlock)
        r += ser_uint256(self.hashMerkleRoot)
        r += self.nTime.to_bytes(4, "little")
        r += self.nBits.to_bytes(4, "little")
        r += self.nNonce.to_bytes(4, "little")
        r += b"cpunet\x00"
        self.sha256 = uint256_from_str(hash256(r))
        self.hash = hash256(r)[::-1].hex()

CBlock.old_calc_sha256 = CBlock.calc_sha256
CBlockHeader.calc_sha256 = CBlockHeader_calc_sha256

class CPUMiner():
    def __init__(self, args):
        # keep track of chain tip since bitcoind seems to have a race condition.
        self.tip = None

        self.loop = asyncio.new_event_loop()
        self.zmqContext = zmq.asyncio.Context()

        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)
        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "sequence")
        zmqFlags = zmq.EVENT_CONNECTED|zmq.EVENT_CLOSED
        self.zmqMonitor = self.zmqSubSocket.get_monitor_socket(zmqFlags)
        self.zmqSubSocket.connect("tcp://127.0.0.1:28338")

        if args.max_blocks is not None:
            if args.ongoing:
                logging.error("Cannot specify both --ongoing and --max-blocks")
                return 1
            if args.max_blocks < 1:
                logging.error("N must be a positive integer")
                return 1
            self.max_blocks = args.max_blocks
        elif args.ongoing:
            self.max_blocks = None
        else:
            self.max_blocks = 1

        if hasattr(args, "address") and hasattr(args, "descriptor"):
            if args.address is None and args.descriptor is None:
                sys.stderr.write("Must specify --address or --descriptor\n")
                return 1
            elif args.address is not None and args.descriptor is not None:
                sys.stderr.write("Only specify one of --address or --descriptor\n")
                return 1

        self.address = args.address
        self.descriptor = args.descriptor
        self.derived_addresses = {}
        self.reward_spk = None
        self.mining_process = None
        self.mined_blocks = 0

        self.grind_cmd = args.grind_cmd.split(" ")
        self.bcli_basecmd = args.cli.split(" ")

    # We run bitcoin-cli asynchronously so that long-running commands like
    # getblocktemplate don't stall us announcing a mined block or noticing a new
    # block announcement.
    async def bitcoin_cli(self, *args, input=b""):
        cmd = self.bcli_basecmd + ["-cpunet"] + list(args)
        logging.debug("Calling bitcoin-cli: %r", " ".join(cmd))
        if input: logging.debug("    with input=%r", input)
        bcli_process = await asyncio.create_subprocess_exec(*cmd,
            stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        (stdout, stderr) = await bcli_process.communicate(input)
        if bcli_process.returncode != 0:
            logging.error("bitcoin-cli returned an error code %d\n\nstdout = %s \n\nstderr = %s\n"%(bcli_process.returncode, stdout, stderr))
            self.stop()
        logging.debug("    result = %s"%(stdout))
        logging.debug("    stdout = %s"%(stdout))
        logging.debug("    stderr = %s"%(stderr))
        if isinstance(stdout, bytes):
            stdout = stdout.decode('utf8')
        return stdout.strip()

    async def handle_zmq_monitor(self):
        mon_evt = await recv_monitor_message(self.zmqMonitor)
        if mon_evt['event'] == zmq.EVENT_CONNECTED:
            logging.info("ZMQ connected to %s", mon_evt['endpoint'].decode('utf-8'))
            asyncio.ensure_future(self.handle_zmq_monitor())
        elif mon_evt['event'] == zmq.EVENT_CLOSED:
            logging.error("ZMQ connection closed to %s", mon_evt['endpoint'].decode('utf-8'))
            logging.error("    pass `-zmqpubsequence=%s` to bitcoind on startup",
                          mon_evt['endpoint'].decode('utf-8'))
            self.stop()
        else:
            logging.error("Unknown ZMQ Monitor event received: %s", mon_evt)

    async def handle_zmq(self):
        if self.tip == None:
            self.tip = json.loads(await self.bitcoin_cli("getblockchaininfo"))["bestblockhash"]
        topic, body, seq = await self.zmqSubSocket.recv_multipart()
        sequence = "Unknown"
        if len(seq) == 4:
            sequence = str(struct.unpack('<I', seq)[-1])
        if topic == b"sequence":
            hash = body[:32].hex()
            label = chr(body[32])
            mempool_sequence = None if len(body) != 32+1+8 else struct.unpack("<Q", body[32+1:])[0]
            if label == 'C': # Connected a new block tip
                logging.info("Connected new block tip %s"%hash)
                self.tip = hash
                if self.mining_process.returncode == None: # has not terminated yet
                    self.mining_process.terminate()        # someone else mined this block
            else:
                logging.debug("Saw ZMQ sequence message with unhandled label=%s"%label)
        else:
            logging.error("ZMQ message with unknown topic: %s"%topic)

        asyncio.ensure_future(self.handle_zmq())

    async def handle_grind(self):

        if self.max_blocks is not None and self.mined_blocks >= self.max_blocks:
            logging.info("Mined requested %d blocks, exiting."%max_blocks)
            self.stop()

        # gbt
        while True:
            tmpl = json.loads(await self.bitcoin_cli("getblocktemplate", '{"rules":["segwit"]}'))
            logging.debug("GBT template: %s", tmpl)
            if tmpl["previousblockhash"] == self.tip:
                break
            else:
                logging.warning("getblocktemplate returned a block with the wrong previousblockhash")
                logging.warning("\ttip =               ", self.tip)
                logging.warning("\tpreviousblockhash = ", tmpl["previousblockhash"])

        # Get address and scriptPubKey for reward
        self.reward_addr, self.reward_spk = await self.get_reward_addr_spk(tmpl["height"])

        # Construct coinbase transaction
        cbtx = CTransaction()
        cbtx.vin = [CTxIn(COutPoint(0, 0xffffffff),
                          script_BIP34_coinbase_height(tmpl["height"]), 0xffffffff)]
        cbtx.vout = [CTxOut(tmpl["coinbasevalue"], self.reward_spk)]
        cbtx.vin[0].nSequence = 2**32-2
        cbtx.rehash()

        # Construct block
        block = CBlock()
        block.nVersion = tmpl["version"]
        block.hashPrevBlock = int(tmpl["previousblockhash"], 16)
        block.nTime = tmpl["curtime"]
        if block.nTime < tmpl["mintime"]:
            block.nTime = tmpl["mintime"]
        block.nBits = int(tmpl["bits"], 16)
        block.nNonce = 0
        block.vtx = [cbtx] + [tx_from_hex(t["data"]) for t in tmpl["transactions"]]
        block.hashMerkleRoot = block.calc_merkle_root()

        # Mine Block
        logging.info("Mining Block: %s"%(block))
        headhex = CBlockHeader.serialize(block).hex()
        cmd = self.grind_cmd + [headhex]
        logging.debug("Calling grind command: %r"%(" ".join(cmd)))
        self.mining_process = await asyncio.create_subprocess_exec(*cmd,
            stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
        (stdout, stderr) = await self.mining_process.communicate()
        if self.mining_process.returncode == -subprocess.signal.SIGTERM:
            logging.info("Mining process terminated with SIGTERM: restarting mining process.")
        elif self.mining_process.returncode == EXIT_FAILURE:
            if stderr == b"Could not satisfy difficulty target\n":
                # By starting over here we get a new timestamp and a new block
                # header to grind against. (So we're not re-grinding the same
                # nonce range with the same block header)
                logging.debug("Mining process ran out of nonce space. Restarting mining.")
                pass
            else:
                logging.error("Grind command returned with EXIT_FAILURE.  Exiting.")
                self.stop()
        elif self.mining_process.returncode == 0: # Success
            self.mined_blocks += 1
            newhead = from_hex(CBlockHeader(), stdout.decode('utf8'))
            block.nNonce = newhead.nNonce
            block.rehash()

            # Submit block
            r = await self.bitcoin_cli("-stdin", "submitblock", input=block.serialize().hex().encode('utf8'))
            logging.debug("Submitting block: %s", block.serialize().hex())
            if r != "":
                logging.warning("submitblock returned %s for height %d hash %s", r, tmpl["height"], block.hash)

            # Report
            logging.info("Mined a block solution at height %d with hash: %s"%(tmpl["height"], block.hash))
            logging.debug("Block hash %s payout to %s", block.hash, self.reward_addr)
            logging.debug("Solved block is %s", block)

        # Run the next iteration
        asyncio.ensure_future(self.handle_grind())

    async def get_reward_address(self, height):
        if self.address is not None:
            return self.address

        if '*' not in self.descriptor:
            addr = json.loads(await self.bitcoin_cli("deriveaddresses", self.descriptor))[0]
            self.address = addr
            return addr

        remove = [k for k in self.derived_addresses.keys() if k+20 <= height]
        for k in remove:
            del self.derived_addresses[k]

        addr = self.derived_addresses.get(height, None)
        if addr is None:
            addrs = json.loads(await self.bitcoin_cli("deriveaddresses", self.descriptor, "[%d,%d]" % (height, height+20)))
            addr = addrs[0]
            for k, a in enumerate(addrs):
                self.derived_addresses[height+k] = a

        return addr

    async def get_reward_addr_spk(self, height):
        assert self.address is not None or self.descriptor is not None

        if self.reward_spk is not None:
            return self.address, self.reward_spk

        reward_addr = await self.get_reward_address(height)
        reward_spk = bytes.fromhex(json.loads(await self.bitcoin_cli("getaddressinfo", reward_addr))["scriptPubKey"])
        if self.address is not None:
            # will always be the same, so cache
            self.reward_spk = reward_spk

        return reward_addr, reward_spk

    def start(self):
        self.loop.add_signal_handler(signal.SIGINT, self.stop)
        self.loop.create_task(self.handle_zmq_monitor())
        self.loop.create_task(self.handle_zmq())
        self.loop.create_task(self.handle_grind())
        self.loop.run_forever()

    def stop(self):
        for task in asyncio.all_tasks():
            task.cancel()
        self.loop.stop()
        self.zmqContext.destroy()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--cli", default="bitcoin-cli", type=str, help="bitcoin-cli command")
    parser.add_argument("--debug", action="store_true", help="Print debugging info")
    parser.add_argument("--quiet", action="store_true", help="Only print warnings/errors")

    parser.add_argument("--ongoing", action="store_true", help="Keep mining blocks")
    parser.add_argument("--max-blocks", default=None, type=int, help="Max blocks to mine (default=1)")

    parser.add_argument("--address", default=None, type=str, help="Address for block reward payment")
    parser.add_argument("--descriptor", default=None, type=str, help="Descriptor for block reward payment")

    parser.add_argument("--grind-cmd", default="bitcoin-util -cpunet grind", type=str, required=True, help="Command to grind a block header for proof-of-work")

    args = parser.parse_args(sys.argv[1:])

    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    elif args.quiet:
        logging.getLogger().setLevel(logging.WARNING)
    else:
        logging.getLogger().setLevel(logging.INFO)

    daemon = CPUMiner(args)
    daemon.start()

if __name__ == "__main__":
    main()
